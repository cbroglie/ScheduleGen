#!/usr/bin/env python

import copy
import pdb
from libsched import schedule

def assign(schedule, week, matchup):
    """Eliminate all matchups other than the given one from the provided week,
    and propagate. Return the schedule, except return False if a contradiction
    is detected."""
    for team in matchup:
        if not all(eliminate(schedule, week, matchup2)
                   for matchup2 in copy.copy(schedule.teams[team][week]) if matchup2 != matchup):
            return False
        # Check how many times we can play this team. Eliminate matchups from
        # all other weeks if we have hit the max, or all weeks within the min
        # rematch buffer if we are under the limit still.
        team2 = list(set(matchup) - set([team]))[0]
        num_matchups = schedule.get_num_matchups(team, team2)
        max_matchups = schedule.get_matchup_max(team, team2)
        if not all(eliminate(schedule, week2, matchup2)
                   for week2 in range(schedule.num_weeks) if week2 != week and len(schedule.teams[team][week2]) > 1
                   for matchup2 in copy.copy(schedule.teams[team][week2]) if set(matchup2) & set([team2]) and
                                                                          (num_matchups >= max_matchups or
                                                                           abs(week2 - week) <= schedule.min_weeks_between_matchups)):
            #print "Failing from too many matchups"
            return False
        # If we have hit the limit for divisional games, eliminate all other
        # divisional matchups.
        total_division_games = ((schedule.num_teams / schedule.num_divisions) - 1) * schedule.min_division_matchups
        if schedule.get_num_division_games(team) >= total_division_games:
            if not all(eliminate(schedule, week2, matchup2)
                       for week2 in range(schedule.num_weeks) if week2 != week and len(schedule.teams[team][week2]) > 1
                       for matchup2 in copy.copy(schedule.teams[team][week2]) if schedule.same_division(matchup2[0], matchup2[1])):
                #print "Failing from too many divisional games"
                return False
        # If we have it the limit for non-divisional games, eliminate all other
        # non-divisional games.
        if schedule.get_num_non_division_games(team) >= schedule.num_weeks - total_division_games:
            if not all(eliminate(schedule, week2, matchup2)
                       for week2 in range(schedule.num_weeks) if week2 != week and len(schedule.teams[team][week2]) > 1
                       for matchup2 in copy.copy(schedule.teams[team][week2]) if not schedule.same_division(matchup2[0], matchup2[1])):
                #print "Failing from too many non-divisional games"
                return False
        # If we are over the max home games, eliminate home matchups from other
        # weeks.
        if schedule.get_num_home_games(team) >= ((schedule.num_weeks + 1) & ~0x1) / 2:
            if not all(eliminate(schedule, week2, matchup2)
                       for week2 in range(schedule.num_weeks) if week2 != week and len(schedule.teams[team][week2]) > 1
                       for matchup2 in copy.copy(schedule.teams[team][week2]) if matchup2[0] == team):
                #print "Failing from too many home games"
                return False
        # Same for away games.
        if schedule.get_num_away_games(team) >= ((schedule.num_weeks + 1) & ~0x1) / 2:
            if not all(eliminate(schedule, week2, matchup2)
                       for week2 in range(schedule.num_weeks) if week2 != week and len(schedule.teams[team][week2]) > 1
                       for matchup2 in copy.copy(schedule.teams[team][week2]) if matchup2[1] == team):
                #print "Failing from too many away games"
                return False
    # Check if we violated any constraints by removing other matchups.
    for team in schedule.teams:
        if not schedule.valid(team):
            #print "Failing from invalid schedule"
            return False
    return schedule

def eliminate(schedule, week, matchup):
    """Elimniate matchup from the given week. Propagate when possible. Return
    schedule, except return False if a contradiction is detected."""
    #print "Removing %r from week %d" % (matchup, week)
    for team in matchup:
        # TODO: Use lookahead to fail faster
        if matchup in schedule.teams[team][week]:
            schedule.remove_matchup(team, week, matchup)
        else:
            continue

        # Contradiction: removed last value.
        if len(schedule.teams[team][week]) == 0:
            return False

        # If a slot is reduced to one value, eliminate the value from its peers.
        if len(schedule.teams[team][week]) == 1:
            matchup2 = schedule.teams[team][week][0]
            #print "%r is the last matchup in week %d for team %d" % (matchup2, week, team)
            #pdb.set_trace()
            if not all(eliminate(schedule, week, matchup3)
                       for team2 in schedule.teams if not set([team2]) & set(matchup2)
                       for matchup3 in copy.copy(schedule.teams[team2][week]) if set(matchup2) & set(matchup3)):
                return False
    return schedule

def search(schedule):
    """Using depth first search and propagation, try all possible values."""
    if schedule is False:
        return False # Already failed earlier
    if all(len(schedule.teams[team][week]) == 1
           for team in schedule.teams
           for week in range(schedule.num_weeks)):
        return schedule # Solved
    # Choose the team and week with the fewest possibilities
    count, team, week = min((len(schedule.teams[team][week]), team, week)
                            for team in schedule.teams
                            for week in range(schedule.num_weeks) if len(schedule.teams[team][week]) > 1)
    print "Searching team %d for week %d" % (team, week)
    # TODO: Make lighterweight version of deepcopy (arrays and dicts can be
    # shallow copies)
    return some(search(assign(copy.deepcopy(schedule), week, matchup))
                for matchup in schedule.teams[team][week])

def some(seq):
    """Return some element of seq that is true."""
    for e in seq:
        if e: return e
    return False

if __name__ == "__main__":
    schedule = schedule.Schedule()
    schedule.num_weeks = 13
    schedule.num_teams = 16
    schedule.num_divisions = 4
    schedule.min_division_matchups = 2
    schedule.max_division_matchups = 2
    schedule.max_non_division_matchups = 1
    schedule.min_weeks_between_matchups = 4
    schedule.init()

    schedule = search(schedule)
    assert schedule is not False

    schedule.display()
    schedule.test()